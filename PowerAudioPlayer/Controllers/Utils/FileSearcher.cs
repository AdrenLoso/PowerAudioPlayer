//Generated by AI
using System.Collections.Concurrent;
using System.IO;

namespace PowerAudioPlayer.Controllers.Utils
{
    public delegate bool SearchFileCallback(string file);

    public static class FileSearcher
    {
        public static IEnumerable<string> SearchFiles(
            string directoryPath,
            string[] fileExtensions,
            bool searchSubdirectories,
            SearchFileCallback? callback = null,
            bool ignoreInaccessible = true)
        {
            if (!Directory.Exists(directoryPath))
            {
                throw new DirectoryNotFoundException($"Directory was not found: {directoryPath}");
            }

            var matchingFiles = new ConcurrentBag<string>();
            var cts = new CancellationTokenSource();

            try
            {
                TraverseDirectories(
                    directoryPath,
                    searchSubdirectories,
                    ignoreInaccessible,
                    cts.Token,
                    file =>
                    {
                        if (fileExtensions.Contains("*" + Path.GetExtension(file)))
                        {
                            matchingFiles.Add(file);
                            if (callback != null && !callback(file))
                            {
                                cts.Cancel();
                            }
                        }
                    });
            }
            catch (OperationCanceledException)
            {
                // 正常终止，由回调取消
            }
            catch (Exception ex) when (ignoreInaccessible && IsAccessException(ex))
            {
                // 忽略访问异常
            }

            return matchingFiles;
        }

        private static bool IsAccessException(Exception ex)
        {
            return ex is UnauthorizedAccessException || ex is DirectoryNotFoundException;
        }

        private static void TraverseDirectories(
            string rootDir,
            bool searchSub,
            bool ignoreInaccessible,
            CancellationToken ct,
            Action<string> processFile)
        {
            var dirStack = new Stack<string>();
            dirStack.Push(rootDir);

            while (dirStack.Count > 0 && !ct.IsCancellationRequested)
            {
                string currentDir = dirStack.Pop();

                // 处理文件
                IEnumerable<string> files;
                try
                {
                    files = Directory.EnumerateFiles(currentDir);
                }
                catch (Exception ex) when (ignoreInaccessible && IsAccessException(ex))
                {
                    continue;
                }

                foreach (var file in files)
                {
                    if (ct.IsCancellationRequested) return;
                    processFile(file);
                }

                // 处理子目录
                if (searchSub)
                {
                    IEnumerable<string> subDirs;
                    try
                    {
                        subDirs = Directory.EnumerateDirectories(currentDir);
                    }
                    catch (Exception ex) when (ignoreInaccessible && IsAccessException(ex))
                    {
                        continue;
                    }

                    foreach (var dir in subDirs.Reverse())
                    {
                        dirStack.Push(dir);
                    }
                }
            }
        }
    }
}